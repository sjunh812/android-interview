# 🎙 Android Interview
안드로이드 신입 개발자 면접을 위한 간단한 개념 및 질문 정리  
<br>  

## 목차
1. [Android](#Android)
2. [Kotlin](#Kotlin)
3. [CS](#CS)
<br>

## Android
### 1. Android 4대 컴포넌트 
안드로이드는 4개의 컴포넌트로 구성되어 있음. (`Activity`, `Service`, `Broadcast Receiver`, `Content Provider`)
- `Actvity` : **UI** 가 있어, 사용자와 직접적인 상호작용을 하는 컴포넌트
- `Service` : 백그라운드에서의 작업을 수행하는 컴포넌트
  - 포그라운드 서비스 : 알림(`Notification`)이 필요
  - 백그라운드 서비스 : **UI** 가 없음
  - 바인드 서비스 : 앱 내에서 서비스를 사용하여 간단한 **서버-클라이언트** 환경 구성
- `Broadcast Receiver` : 디바이스에서 발생하는 다양한 이벤트 및 정보를 받고 반응하는 컴포넌트
  - 정적 리시버 : **Manifest** 에 등록, 해제 불가능
  - 동적 리시버 : 클래스 파일에 동적으로 등록 및 해제 (적절히 해제하지 않을 경우 **메모리 누수** 발생)
- `Content Provider` : 데이터를 저장하고, 가져오며, 다른 앱에 접근할 수 있도록 하는 컴포넌트
  - 다른 앱의 데이터를 사용하기 위해 **URI** 를 이용하여, 콘텐츠 리졸버가 다른 앱의 콘텐츠 프로바이더에게 요청
  - 요청 받은 콘텐츠 프로바이더는 **URI** 를 확인하고, 데이터를 콘텐츠 리졸버에게 전달 

### 2. Activity 와 Fragment 차이
1. `Activity` 는 독립적으로 사용 가능
2. `Fragment` 는 `Activity` 에 종속
3. `Activity` 는 전체화면을 차지하나, `Fragment` 는 꼭 전체화면을 차지하지 않아도 됨

### 3. Activity, Fragment Lifecycle
- Activity Lifecycle : `onCreate()` → `onStart()` → `onResume()` → `onPause()` → `onStop()` → `onDestroy()`
  * `onPause()` 이후 해당 액티비티로 다시 돌아올 경우, `onResume()` 호출
  * `onStop()` 이후 해당 액티비티로 다시 돌아올 경우, `onRestart()` → `onStart()` → `onResume()` 순서로 Lifecycle 실행
  * **configuration** 이 발생할 경우 `onCreate()` 부터 다시 실행
- Fragment Lifecycle : `onAttach()` → `onCreate()` → `onCreateView()` → `onActivityCreated()` → `onStart()` → `onResume()`  
→ `onPasue()` → `onStop()` → `onDestroyView()` → `onDestroy()` → `onDetach()`

### 4. Intent
인텐트는 컴포넌트 간에 정보를 주고 받을 수 있는 **Message Object**(메시징 객체) 이다.
* `PendingIntent` : 인텐트를 가지고 있는 클래스로, 다른 앱의 권한을 허용하여 가지고 있는 인텐트를 마치 본인 앱에서 실행하는 것처럼 사용하는 것

### 5. ANR
**ANR(Application Not Responding)** 은 안드로이드 앱의 **메인 스레드(UI 스레드)** 가 오랫동안 차단되면 발생하는 오류 

### 6. Annotation
**Annotation** 은 주석의 의미를 가지고 있으며,  
특정 클래스, 변수, 메소드 등에 붙이는 코드로 해당 타겟의 기능을 좀 더 명확하게 해주는 역할  

### 7. Context
컨텍스트는 여러 컴포넌트의 상위 클래스  
안드로이드 시스템은 애플리케이션 또는 컴포넌트를 컨텍스트로 관리 (리눅스의 프로세스 ID 와 유사)

### 8. Process Lifecycle
안드로이드는 프로세스를 가능한 오랫동안 유지하려고 하지만,  
새로운 프로세스를 생성하거나, 우선순위가 높은 프로세스의 메모리를 확보하기 위해  
다른 프로세스를 종료시키는 경우가 있음
1. **Foreground Process** : 현재 조작하는 일에 대한 프로세스
2. **Visible Process** : Foreground 상태에 놓여있지는 않지만, 사용자 화면에는 보이는 프로세스 (ex) 다이얼로그가 띄워진 액티비티)  
3. **Service Process** : 서비스가 실행되는 프로세스 (사용자가 하고 있는 일에 영향)
4. **Background Process** : `Activity` 는 있으나, `onStop()` 이 불린 이후여서, 더이상 사용자에게 보이지 않는 프로세스
5. **Empty Process** : **Activity Componet** 를 갖고 있지 않는 프로세스 (다음 재실행 시, 걸리는 시간을 줄이기 위해 캐싱된 프로세스)

### 9. SharedPreferences
안드로이드에서 사용할 수 있는 데이터 저장소  
데이터를 **XML** 파일에 저장  
데이터를 저장한 파일은 앱 폴더 내에 저장되므로, 앱이 삭제되면 데이터도 함께 삭제 

### 10. Intent 와 Bundle
인텐트는 데이터를 전달하는 수단의 객체  
번들은 데이터를 저장하기 위한 객체

### 11. Android Architecture
안드로이드 아키텍처는 4가지의 **key component** 로 이루어져 있음
1. **Linux Kernel** : 메모리 관리, 보안 설정, 네트워크 시스템 관리를 담당
2. **Libraries and Runtime** : 안드로이드 기능 라이브러리와 가상머신의 역할  
모바일 데이터베이스, 그래픽을 담당
3. **Android Framework** : 생명주기, 환경설정 등의 역할 (GPS, 리소스 관리)
4. **Android Application** : 안드로이드에서 기본적으로 제공하는 역할 (전화걸기, 브라우저)

### 12. Android Manifest
매니페스트는 안드로이드 프로그램에서 필수적이며,  
코드를 실행하기 전에 안드로이드 시스템이 알아야하는 애플리케이션에 대한 정보를 포함하는 곳 (앱 이름, 컴포넌트 정보 등)  

### 13. OkHttp Interceptor
`Retorfit` 은 내부적으로 `OkHttp` 라이브러리를 이용하여 네트워크 통신을 구현  
**OkHttp Interceptor** 는 **애플리케이션** 과 **OkHttp 코어** 사이의 **요청/응답** 을 가로채는 역할을 함 

### 14. Vector 와 Bitmap
- Vector : 리사이징 되어도 깨지지 않음. 모든 해상도에서 자유자재로 활용 가능 (ex) SVG)
- Bitmap : 픽셀로 구성되어 있으며, 해상도에 따라 깨질 수 있음 (ex) PNG, JPEG)

### 15. Android Jetpack
안드로이드 앱을 구축하는데 도움이 되는 훌륭한 도구 모음  
즉, Jetpack 은 안드로이드 개발자들이 더욱 쉽게 높은 퀄리티의 앱을 개발할 수 있도록 도와주는 라이브러리들의 모음집  
(ex) `Databinding`, `Room`, `Navigation`, `Paging`, `Lifecycles`, `LiveData`)

### 16. JAR, AAR, DEX, APK
- **JAR** (Java Archive) : 해당 플랫폼에서 `Java` 응용 프로그램을 배포하기 위해 고안된 패키지 파일 형식 (클래스 파일, 매니페스트 파일이 포함)
- **AAR** (Android Archive) : 안드로이드 라이브러리 프로젝트의 바이너리 배포판 (리소스 파일 포함)
- **DEX** (Dalvik Excutable) : DVM(Dalvik Virtual Machine)을 위한 실행 파일  
Android SDK 의 DEX 컴파일러에 의해 JVM 바이트 코드를 DVM 바이트 코드로 변환하고, 모든 class 파일을 DEX 파일에 넣음
- **APK** (Android Application Package) : 안드로이드 플랫폼에 배포할 수 있도록 설계된 파일 

### 17. Application class
안드로이드 기본 클래스로, 안드로이드 앱에 대한 모든 컴포넌트, `Activity` 와 `Service` 를 포함하고 있는 클래스  
응용 프로그램/패키지에 대한 프로세스가 생성될 때, 다른 클래스보다 먼저 인스턴트화   

### 18. String, StringBuffer, StringBuilder
- `String` : 불변, 문자를 수정하려면 새로운 객체를 생성해야 함
- `StringBuffer` : 가변, 한번 만들고, 필요에 따라 크기를 변경하여 문자를 변경 (`append()` 와 같이)
- `StringBuilder` : `StringBuffer` 와 유사하나, **동기화를 지원하지 않아 멀티 스레드 환경에 부적합**
<br>

## Kotlin
### 1. Scope Function
- `apply` : 생성과 동시에 초기화, 자기 자신 return
- `also` : 수신 객체를 명시적으로 사용하고, 자기 자신 return (ex) 로그)
- `with` : 생성과 동시에 초기화, 특정한 값 return
- `run` : 객체의 값에 쉽게 접근하고, 특정한 값 return
- `let` : 수신 객체를 명시적으로 사용 (ex) null 체크)

### 2. 초기화 지연
변수를 선언할 때, 값을 저장하지 않고, 나중에 저장할 수 있는 방법  
메모리를 효율적으로 사용하기 위해, 그리고 **null-safe** 한 value 를 사용하기 위해 사용됨
- `lateinit`
  - `var` (mutable) 를 사용
  - **primitive** 타입을 사용할 수 없음 (ex) `Int`)
  - 선언 후, 나중에 초기화 해줘도 됨
  - 변수 타입을 반드시 지정해줘야 함 (ex) lateinit var name: String)
- `by lazy` 
  - `val` (immutable) 를 사용
  - 선언과 동시에 초기화 필요
  - 호출되는 시점에서 실질적인 초기화가 이루어짐 (메모리룰 효율적으로 사용) 
  - ex) val age by lazy { 10 }

### 3. 동등성과 동일성
- 동등성 (equality) : 두 객체의 값이 같은지 비교, 값을 비교하며, 내부적으로 `equal()` 호출 (`==`)
- 동일성 (identity) : 두 객체가 같은 주소를 참조하는지 비교, 주소값을 비교하며, 식별자를 기반으로 객체 판단 (`===`)

### 4. data class 에서 copy()를 사용하는 이유? data class 를 왜 불변으로 권장하는지?
`copy()` 를 사용하면, 복사를 하여 일부 프로퍼티를 바꾸거나, 복사본을 삭제해도 프로그램에서 원본을 참조하는 다른 부분에 전혀 영향이 없음  

data class 를 키로 하는 컨테이너를 만들고, 키로 쓰인 data class 의 프로퍼티를 변경하면, 컨테이너 상태에 문제가 생길 수 있음 → 불변 권장  
멀티 스레드의 경우 스레드가 사용 중인 data class 를 다른 스레드에서 변경할 수 없으므로 **동기화** 가 필요 없게 됨

### 5. 중첩 클래스와 내부 클래스 차이
바깥쪽 클래스에 대한 참조를 저장하는지, 안하는지 차이  
(중첩 클래스 : class A (static), 내부 클래스 : inner class B)

### 6. Companion object
클래스가 메모리에 적재되면서, 함께 생성되는 객체 (`Java` 의 **static** 과 유사)  
static 과 다르게, companion object 는 변수로 할당 가능하고, 할당된 변수를 통해 멤버를 참조할 수 있음  
<br>  

## CS
### 1. Singleton
싱글톤 패턴은 특정 클래스에 대한 인스턴스를 **단 한번만** static 영역의 메모리에 할당하고, 해당 클래스에 대한 생성자를 여러번 호출 하더라도,  
최초에 생성된 객체를 반환하는 디자인 패턴  
**즉, 애플리케이션의 유일한 객체를 보장하는 디자인 패턴**  
#### 장점
- 고정된 메모리 영역을 얻으면서, 한 번의 new 인스턴트를 생성하여 사용하기 때문에 메모리 낭비 방지
- 전역 인스턴트 때문에 공유가 쉬움
#### 단점
- 싱글톤 인스턴트를 너무 많이 사용하거나, 많은 데이터를 공유시킬 경우, **결합도** 가 높아져 **개방 폐쇠 원칙** 에 위배  
(객체지향 설계 원칙에 어긋)
- 동기화 처리를 안하면, 인스턴트가 두 개 생성되는 문제 발생

### 2. MVC, MVP, MVVM
#### MVC (Model, View, Controller)
안드로이드에서는 Controller 를 따로 나눌 수 없기 때문에, View 와 Controller 의 하는 일을 `Activity` 혹은 `Fragment` 에서 하게 됨
- 장점
  - 코드만 읽을 수 있다면, 다른 패턴에 비해 쉽게 해석 가능
  - 개발 기간이 짧을 수 있음
- 단점
  - 유닛 테스트가 어려움
  - 시간이 지남에 따라 코드가 길게 작성되어, 문제가 발생하기 쉬움
  - View 와 Model 의 결합도가 높음
#### MVP (Model, View, Presenter)
View 가 **수동적**, 기존 MVC 에서는 Model 데이터를 View 에서 직접 반영했다면, MVP 는 명령하는 주체인 **Presenter** 가 View 에게 데이터를 보여달라고 명령하는 형태
- 장점
  - View 와 Model 의 의존성이 없음
  - 새로운 기능 추가 및 변경사항이 있을 때, 관련된 부분만 수정하면 되므로, 확장성이 좋음
  - 테스트 코드의 작성이 편리
- 단점
  - MVC 에서는 View 에서 모든 데이터를 처리했다면, MVP 에서는 `View → Presenter → View → Presenter..` 와 같이 코드 작성
  - View 와 Presenter 는 **1:1** 관계이므로, View 1개에는 Presenter 1개가 무조건 있어야함  
  (View 와 Presenter 의 의존 관계가 강함)
#### MVVM (Model, View, ViewModel)
MVP 와 반대로 View 가 **능동적**, View 는 스스로 ViewModel 의 객체를 관찰함  
`LiveData`, `Observable`, `ObservableField` 등을 사용하여 관찰필드에 변화가 생기면, View 가 알림을 받고, 알맞는 View 랜더링 로직을 수행  
(`Databinding` 을 통해 View 와 ViewModel 사이의 일을 UI 코드로 작성하여, **View 와 ViewModel 의 독립성을 높일 수 있음**)
- 장점
  - 유닛 테스트에 용이
  - View 의 의존성이 없음
  - View 와 ViewModel 의 종속성이 **1:n** 으로 사용가능
- 단점
  - 사전에 알아야할 사항이 많음 (구조, Databinding, BindingAdapter)
  - 비교적 유지보수가 힘들 수 있음 (XML, ViewModel, BindingAdapter)

### 3. DI
DI (Dependency Injection) 은 **의존성 주입** 으로, 필요로 하는 객체를 직접 생성하지 않고, 외부로 부터 주입받는 기법을 의미
- Dependency (의존) : 함수에 필요한 클래스 또는 참조변수나 객체에 의존하는 것 
- Injection (주입) : 외부에서 객체를 생성해서 넣어주는 것 

### 4. 함수형 프로그래밍과 객체지향 프로그래밍
#### 프로그래밍 패러다임
- 명령형 프로그래밍
  - 절차지향 프로그래밍 : 수행해야 할 연속적인 계산 과정을 포함하는 프로그래밍
  - 객체지향 프로그래밍 : 객체들의 집합으로 프로그램의 상호작용을 표현 
- 선언형 프로그래밍
  - 함수형 프로그래밍 : 순수 함수를 조합하여 프로그램을 만드는 방식
#### 함수형과 객체지향의 차이
객체지향은 객체 안에 상태를 저장하고, 상태변화를 설정하고, 조정하기 위해 다양한 기능을 사용  
이에 반해 함수형은 상태를 제어하는 것보다, 상태를 저장하지 않고 없애는데 포인트

### 5. 직렬화, 역직렬화
#### 직렬화
메모리에 존재하는 정보(객체 또는 데이터)를 보다 쉽게 전달, 전송하기 위해 **byte** 형태로 데이터를 변환하는 기술  
(JVM 의 메모리에 상주되어 있는 객체 데이터를 바이트 형태로 변환하는 기술)
#### 역직렬화
byte 로 변환되어 있는 데이터를 원래대로 객체나 데이터로 변환하는 기술  
(직렬화된 바이트 형태의 데이터를 객체로 변환해서 JVM 에 상주시키는 형태)  
#### Serializable
- **Implement** (구현) 하는 것만으로 쉽게 직렬화를 할 수 있음
- **Reflection** 을 사용하여 직렬화를 처리하므로, 추가로 많은 객체가 생성되어 가비지 컬렉터의 표적이 되고, 성능이 문제로 이어질 수 있음  
(**Reflection** : run-time 에서 동적으로 클래스들의 정보를 알아내고 실행할 수 있는 것)
#### Parcelable
- 안드로이드에서 권장하는 직렬화 방법
- **Serializable** 이 했던 **Reflection** 을 사용하지 않도록 설계되어 있어, 개발자가 수동적으로 해야하는 작업이 있음  
→ Kotlin 의 `@Parcelize` 어노테이션을 통해 쉽게 구현

### 6. Process, Thread
#### Process
컴퓨터에서 연속적으로 실행되고 있는 프로그램  
프로세스는 운영체제로부터 시스템 자원을 할당 받는 작업의 단위 
#### Thread
운영체제로부터 자원을 할당 받은 프로세스 내에서 실행되는 최소 단위  
스레드에는 `start` 와 `run` 방식이 있음
- `start` : **JVM** 에서 스레드를 위한 call stack(stack 영역) 을 새로 만들기 때문에, 독립적으로 사용 가능
- `run` : 메인스레드에서 call stack 을 사용하기 때문에, `run` 메소드가 끝나기 전까지 다른 작업을 하지 못함
#### Muti Thread
프로그램의 흐림이 2개 이상인 것을 말함  
매우 빠른 시간 간격으로 **스위칭** 되기 때문에 동시에 실행되는 것처럼 보임 (**동시성**)  
- **Context Switching** : 하나의 프로세스가 CPU 를 사용 중인 상태에서 다른 프로세스가 CPU 를 사용하도록 하기 위해,  
이전 프로세스 상태를 보관하고, 새로운 프로세스의 상태를 적재하는 작업

### 7. Framework, Library
- Framework : 특정 프로그램을 개발하기 위한 여러 요소들과 메뉴얼인 룰을 제공하는 프로그램
- Library : 소프트웨어를 개발하기 쉽게 어떤 기능을 제공하는 도구  

**프레임워크는 꼭 써야하는 것과 지켜야하는 룰이 있지만, 라이브러리는 사용 여부를 개발자 마음대로 할 수 있음 (자유도의 차이)** 

### 8. JVM
**Java Virtual Machine** 의 약자로 자바 바이트 코드를 실행할 수 있는 주체  
운영체제 위에서 동작하는 프로세스로, 자바 코드를 컴파일해서 얻은 바이트 코드를 해당 운영체제가 이해할 수 있는 기계어로 바꿔 실행시켜주는 역할  
- Class Loader : 자바 소스를 컴파일하면 `.class` 파일이 생성되는데, 클래스 파일들을 엮어 JVM 이 운영체제로부터 할당 받은 메모리 영역 Runtime Data Area 에 적재하는 역할
- Execution Engine : Class Loader 에 의해 메모리에 적재된 클래스들을 기계어로 변환하여, 명령어 단위로 실행하는 역할
- Garbage Collector : 참조되지 않는 객체들을 탐색 후 제거하는 역할
- Runtime Data Area : JVM 의 메모리 영역으로, 자바 애플리케이션이 실행될 때, 사용되는 데이터를 적재하는 영역

### 9.REST, REST API, RESTful
#### REST
- **Representational State Transfer** 의 약자
- 기본적으로 웹의 기존 기술과 **HTTP Protocol** 을 그대로 활용하기 때문에, 웹의 장점을 최대한 활용할 수 있는 아키텍처 스타일
- 네트워크 상에서 서버와 클라이언트 사이의 통신 방식 중 하나
- 자원을 `URI` 로 표시하고, 자원의 상태를 주고 받는 일을 함
- 장점
  - HTTP 표준 프로토콜을 사용한 모든 플랫폼에서 사용 가능
  - 서버와 클라이언트 역할을 명확하게 분리
- 단점
  - 표준이 존재하지 않음
  - 사용할 수 있는 메소드가 제한적 (`GET`, `POST`, `PUT`, `DELETE`) 

#### REST API
- REST 를 기반으로 API 를 구현  
- REST 를 기반으로 시스템을 분산해, 확장성과 재사용성을 높여 유지보수 및 운용을 편리하게 할 수 있음  
- HTTP 를 지원하는 프로그래밍 언어로 클라이언트와 서버를 구현할 수 있음

#### RESTful
- REST 를 REST 답게 쓰는 방법으로, 사용하기 쉽고, 이해하기 쉬운 REST API 를 만드는 것  
- 반례 : CRUD 를 `POST` 로만 구현, 루트에 자원과 ID 외 정보가 있는 경우

### 10. OSI
여러 통신 업체 장비들은 자신의 업체 장비 간만 연결이 되는등 호환성이 없음  
그래서 통신이 일어나는 과정을 단계별로 나눠 **표준화** 한 **OSI 7계층** 을 정의

#### 1계층 (물리 계층)
- 프로토콜 : 전파, 전선, 광섬유..
- 기능 : 물리적 연결기의 전기적 명세를 정하고, 네트워크 두 노드를 물리적으로 연결시켜주는 신호 방식을 다룸
- 단위 : `bit`

#### 2계층 (데이터 링크 계층)
- 프로토콜 : Token, 무선랜..
- 기능 : 물리 계층을 통해 송수신 되는 정보의 오류와 흐름을 관리하여, 안전한 정보의 전달을 수행할 수 있도록 도와주는 역할
- 단위 : `frame` (`bit`의 모음)

#### 3계층 (네트워크 계층)
- 프로토콜 : IP, ICMP..
- 기능 : 데이터를 목적지까지 안전하고 빠르게 전달하는 기능 (라우팅)
- 단위 : `패킷`

#### 4계층 (전송 계층)
- 프로토콜 : TCP, UDP
- 기능 : 통신을 활성화하기 위한 계층 (패킷이 유효한지 확인)

#### 5계층 (세션 계층)
- 프로토콜 : TLS, SSH
- 기능 : 사용자 간의 포트 연결(세션)이 유효한지 확인하고 설정 

#### 6계층 (표현 계층)
- 프로토콜 : JPEG, MPEG
- 기능 : 입출력되는 데이터를 하나의 표현 형태로 변환

#### 7계층 (응용 계층)
- 프로토콜 : HTTP, SMTP
- 기능 : 사용자가 네트워크에 접근할 수 있도록 하는 계층

### 11. TCP, IP
- TCP : **전송 조절 프로토콜**, IP 보다 느리지만, 꼼꼼한 방식으로 도착한 데이터를 점검하고, 누락된 데이터를 재요청하여 정렬
- IP : **패킷 통신의 인터넷 프로토콜**, 데이터의 조각들을 최대한 빠르게 목적직로 전달하는 역할 (순서가 뒤바뀌거나, 일부 누락되어도 상관하지 않고 보내는데 집중)
- TCP/IP 4계층
  - 1계층 : 네트워크 엑세스 (OSI 의 1,2계층)
  - 2계층 : 인터넷 계층 (OSI 의 3계층)
  - 3계층 : 전송 계층 (OSI 의 4계층)
  - 4계층 : 응용 계층 (OSI 의 5,6,7계층)

### 12. 동기, 비동기
- 동기 (Synchronous)
  - 동시에 일어난다는 뜻
  - 바로 요청을 하면, 시간이 얼마 걸리던지 요청한 자리에서 결과가 주어짐  
  (요청과 결과가 한자리에서 동시에 발생)
- 비동기 (Asynchronous)
  - 동시에 일어나지 않음을 의미
  - 요청과 결과가 그 자리에서 이루어지지 않음

### 13. Compile time, Run time
- Compile-time : 개발자가 작성한 코드를 컴퓨터가 이해할 수 있는 기계어 코드로 변환
- Run-time : 컴파일 과정을 마쳐서, 사용자에 의해 실행되어짐

### 14. 스택, 큐
- 스택 (Stack) 
  - **LIFO (Last In First Out)**, 즉 후입선출의 방식으로 동작
  - 스택에서 가장 위에 있는 항목을 제거하는 동작은 `pop()`, 추가하는 동작은 `push()` 라고 함
- 큐 (Queue)
  - **FIFO (First In First Out)**, 즉 선입선출의 방식으로 동작
  - 큐에 자료를 한개 집어 넣는 동작을 `Enqueue`, 큐 안에 있는 자료를 한개 꺼내는 동작을 `Dequeue` 라고 함
- Deque : 자료의 입출력을 양쪽에서 가능하게 하는 자료구조

### 15. 쿠키, 세션
`HTTP` 는 브라우저 같은 응용 프로그램을 통해 사용자와 서버 사이에 전송하는 프로토콜  
이는 연결 상태를 유지하지 않는 **비연결 프로토콜**  
→ 비연결 프로토콜의 단점인 지속적인 재연결 문제를 해결하기 위해 **쿠키** 와 **세션** 을 사용

#### 쿠키 (Cookie)
- 사용자 브라우저에 저장되기 때문에, 서버 자원을 사용할 수 없고, 사용자 컴퓨터만 있으면 누구나 쿠키 안에 데이터를 확인할 수 있으므로 **보안성이 낮음**
- 쿠키는 인터넷 사용자가 웹 서버에 접속할 때, 생성되는 개인 아이디, 비밀번호, 방문한 사이트의 정보를 담은 임시 파일

#### 세션 (Session)
- 클라이언트와 웹 서버간에 네트워크 연결이 지속적으로 유지되고 있는 상태
- 세션에 관련된 데이터는 서버에 저장되므로 **보안성이 높음**
- 웹 브라우저 캐시에 저장되어, 브라우저가 닫히거나, 서버에서 삭제될 때 사라짐
- 캐시 (Cache) : 데이터의 값을 미리 복사하여 임시로 저장해두는 장소

### 16. Collection
여러 원소들을 담을 수 있는 자료구조  
핵심 인터페이스로 `List`, `Set`, `Map` 이 있음
- `List` : 순서가 있는 집합, 데이터 중복을 허용
- `Set` : 순서가 유지되지 않는 집합, 데이터 중복을 허용하지 않음
- `Map` : 순서가 유지되지 않는 집합, **키** 는 데이터 중복을 허용하지 않으며, **값** 은 중복을 허용

### 17. HashTable
검색하고자 하는 **키(key)** 값을 입력 받아서, **해시 함수**를 돌려 반환 받은 해시 코드를 배열의 인덱스로 환산하여 데이터에 접근하는 방식의 자료구조
- 장점
  - 데이터의 저장/읽기 속도가 빠름 (특히 검색 속도)
  - 키에 대한 데이터의 중복 확인이 쉬움
- 단점
  - 일반적으로 저장공간이 많이 필요
  - 여러키에 대한 동일한 주소값(해시 코드)를 갖는 **충돌** 에 대비하여 별도의 자료구조가 필요
 #### HashMap 과 HashTable 의 차이점
 `HashMap` 은 동기화를 지원하지 않고, nullable 함  
 `HashTable` 은 동기화를 지원하고, null 을 허용하지 않음
 
 ### 18. Critical Section
 둘 이상의 프로세스 혹은 스레드가 동시에 접근해서는 안되는 공유 자원에 접근하는 코드의 일부를 의미  
 즉, **race condition (경쟁 상태)** 가 발생할 수 있는 코드의 일부
 #### Race Condition
 공유 자원에 대해 여러 프로세스나 스레드가 동시 접근하여, 접근 타이밍이나 순서에 따라 결과값에 영향을 미치는 상태
 #### 원자성 (Atomicity)
 데이터베이스 시스템의 ACID 트랜잭션 특성 중 하나  
 하나의 원자 트랜잭션은 **모두 성공하거나, 실패하는** 데이터베이스 운용의 집합  
 ex) 티켓 주문 = 티켓의 비용 지불과 좌석 예약은 반드시 동시에 일어나야함
 
 ### 19. Mutex, Semaphore
 #### Mutex
 - 자원에 대한 접근을 동기화하기 위한 **상호배제** 기술
 - 하나의 프로세스 또는 스레드에 의해 소유될 수 있는 **키(Key)** 를 기반으로 되어있음
 #### Semaphore
 - 여러 프로세스 또는 스레드의 수를 나타내는 값을 두어 **상호배제** 를 달성하는 기법
 #### Mutex 와 Semaphore 차이점
 1. 세마포어는 뮤텍스가 될 수 있지만, 뮤텍스는 세마포어가 될 수 없음
 2. 뮤텍스는 소유할 수 있지만, 세마포어는 소유할 수 없음
 3. 동기와의 개수가 다름
 
 ### 20. 블로킹과 논블로킹
 블로킹과 논블로킹의 차이점은 **제어권** 을 누가 가지고 있는지에 있음
 블로킹은 제어권이 호출한 함수에게 넘어가, 함수 내 작업이 모두 끝난 후 제어권이 돌아와 실행  
 논블로킹은 제어권이 나에게 있고, 호출된 함수와 동시에 실행  
 #### 동기, 비동기와의 차이점
 **동기와 비동기** 는 프로세스 또는 스레드의 수행 순서 보장 매커니즘  
 **블로킹과 논블로킹** 은 프로세스의 유휴 상태에 대한 개념  
 
 ### 21. 교착 상태 (Dead Lock)
 교착 상태는 두개 이상의 프로세스 또는 스레드들이 자원을 점유한 상태에서 서로 다른 프로세스(스레드)가 점유하고 있는 **자원을 요구하며, 무한정 기다리는 현상**  
 #### 조건
 4가지 조건 중 한가지라도 만족하지 않으면, 교착 상태가 발생하지 않음
 1. 상호배제 : 한개의 자원은 하나의 프로세스만 사용
 2. 점유와 대기 : 한 프로세스가 하나이상의 자원을 점유하고 있으면서, 다른 프로세스가 점유하는 자원을 기다림
 3. 비선점 : 프로세스가 작업을 마치고, 자원을 반환할 때까지 기다림 (**강제로 빼앗지 않음**)
 4. 환형 대기 : 프로세스 집합에서 순환 형태로 자원을 기다림
